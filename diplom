import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import fsolve
plt.style.use('seaborn-poster')
from scipy.optimize import fsolve


n = 3
R = 8.31
delta = 0.1


e_start = [n * R * 0.25 / 2, n * R * 0.25 / 2, n * R * 0.25 / 2]
e_end = [n * R * 0.165 / 2, n * R * 0.165 / 2, n * R * 0.165 / 2]


v_start = [0.75, 0.75, 0.75]
v_end = [0.55, 0.60, 0.65]


sc = [[n * R / (2 * e_start[i]), \
       - n * R / (2 * e_start[i]) * np.log(v_start[i])] for i in range(3)]
ec = [[n * R / (2 * e_end[i]), \
       - n * R / (2 * e_end[i]) * np.log(v_end[i])] for i in range(3)]


start_time = [0, 0, 0]
end_time = [2.175, 2.03, 1.93]
time_dots = [10000, 10000, 10000]
time_net = [np.linspace(start_time[i], end_time[i], \
                        time_dots[i]) for i in range(3)]


sol = []


# var[0] = q_1, var[1] = q_2, var[2] = l_1, var[3] = l_2
def residual(var):
    return np.sqrt(n * R * delta * (n * var[0]**4 * var[3]**2 + 
                              2 * var[0]**4 * var[2]**2 + 
                              4 * var[0]**3 * var[1] * var[2] * var[3] + 
                              2 * var[0]**2 * var[1]**2 * var[3]**2 - 
                              2 * R * n * var[0]**2 * var[3] + 
                              R**2 * n))


def hamiltonian_system(t, var):
    return (np.array([n * R * delta * (4 * var[0]**4 * var[2] + 4 * var[0]**3 * var[1] * var[3]) / (4 * var[0]**2 * residual(var)), \
                     n * R * delta * (2 * n * var[0]**4 * var[3] + 4 * var[0]**3 * var[1] * var[2] + 4 * var[0]**2 * var[1]**2 * var[3] - 2 * R * n * var[0]**2) / (4 * var[0]**2 * residual(var)), \
                     residual(var) / (4 * var[0]**3) - n * R * delta * (4 * n * var[0]**3 * var[2]**2 + 8 * var[0]**3 * var[2]**2 + 12 * var[0]**2 * var[1] * var[2] * var[3] + 4 * var[0] * var[1]**2 * var[3]**2 - 4 * R * n * var[0] * var[3]) / (4 * var[0]**2 * residual(var)), \
                     - n * R * delta * (4 * var[0]**3 * var[2] * var[3] + 4 * var[0]**2 * var[1] * var[3]**2) / (4 * var[0]**2 * residual(var))])    )


def objective(sl, i):
    sol = solve_ivp(hamiltonian_system, \
                    [start_time[i], end_time[i]], \
                    [sc[i][0], sc[i][1], sl[0], sl[1]], \
                    t_eval = time_net[i])
    q_1 = sol.y[0]
    q_2 = sol.y[1]
    return [q_1[-1] - ec[i][0], q_2[-1] - ec[i][1]]


for i in range(3):
    root = fsolve(objective, [0, 0], args=(i))
    sol.append(solve_ivp(hamiltonian_system, \
                         [start_time[i], end_time[i]], \
                         [sc[i][0], sc[i][1], root[0], root[1]], \
                         t_eval = time_net[i]))


e = [n * R / (2 * sol[i].y[0]) for i in range(3)]
v = [np.exp(- sol[i].y[1] / sol[i].y[0]) for i in range(3)]
T = [2 * e[i] / (n * R) for i in range(3)]


plt.figure(figsize = (10, 10))
for i in range(3):
    plt.plot(T[i], v[i], color="black", linewidth=2)
plt.plot(0.25, 0.75, 'ro', color="black")
plt.plot(0.165, 0.65, 'ro', color="black")
plt.plot(0.165, 0.60, 'ro', color="black")
plt.plot(0.165, 0.55, 'ro', color="black")
plt.xlabel("T")
plt.ylabel(r"$\upsilon$")
plt.savefig("graph.png", dpi=400)

